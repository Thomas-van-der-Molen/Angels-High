/*
Will Chapman
05/06/2019
12/08/2019

	A class that handles all of the physics and animation of the aircraft

*/

#include "AircraftBase.h"
#include <cmath>
#include "EngineNozzle.h"
#include "Runtime/Engine/Public/EngineGlobals.h"

// Sets default values
AAircraftBase::AAircraftBase()
{
 	// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
	
	/*
		PHYSICAL CONSTRUCTION OF AIRCRAFT
	*/

	//Setup core Scene Root
	m_mSceneRoot = CreateDefaultSubobject<USceneComponent>(TEXT("Scene Root"));
	m_mSceneRoot->SetupAttachment(RootComponent);

	//Setup aircraft body
	m_aAircraftComponent = CreateDefaultSubobject<UChildActorComponent>(TEXT("Aircraft Body"));
	m_aAircraftComponent->SetupAttachment(m_mSceneRoot);

	m_aWeapon1 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 1"));
	m_aWeapon1->SetupAttachment(m_aAircraftComponent);
	m_aWeapon2 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 2"));
	m_aWeapon2->SetupAttachment(m_aAircraftComponent);
	m_aWeapon3 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 3"));
	m_aWeapon3->SetupAttachment(m_aAircraftComponent);
	m_aWeapon4 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 4"));
	m_aWeapon4->SetupAttachment(m_aAircraftComponent);
	m_aWeapon5 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 5"));
	m_aWeapon5->SetupAttachment(m_aAircraftComponent);
	m_aWeapon6 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 6"));
	m_aWeapon6->SetupAttachment(m_aAircraftComponent);
	m_aWeapon7 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 7"));
	m_aWeapon7->SetupAttachment(m_aAircraftComponent);
	m_aWeapon8 = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapon 8"));
	m_aWeapon8->SetupAttachment(m_aAircraftComponent);

	/*
		DEFAULTS
	*/
	m_bAfterburner = false;
	m_bAirbrake = false;
	
	/*
		SETUP WEAPON LOADOUT
	*/
	m_aLoadout = CreateDefaultSubobject<UChildActorComponent>(TEXT("Weapons"));
	m_aLoadout->SetupAttachment(m_mSceneRoot);
		
}

// Called when the game starts or when spawned
void AAircraftBase::BeginPlay()
{
	Super::BeginPlay();

	m_pLoadout = Cast<AWeaponLoadout>(m_aLoadout->GetChildActor());
	if (m_pLoadout == nullptr)
		GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, TEXT("FAILED RETRIEVING LOADOUT"));
		
	//Set aircraft model pointer to the child actor component
	m_aAircraftModel = Cast<AAircraftModel>(m_aAircraftComponent->GetChildActor());	
	if (m_aAircraftModel == nullptr)
		GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, TEXT("FAILED RETRIEVING AIRCRAFT"));

	//Set aircraft model pointer to the child actor component
	m_aLeftEngine = Cast<AEngineNozzle>(m_aAircraftModel->m_mLeftEngine->GetChildActor());
	m_aRightEngine = Cast<AEngineNozzle>(m_aAircraftModel->m_mRightEngine->GetChildActor());

	/*
		PHYSICS DEFAULTS
	*/
	m_fCurrentThrust = 0.5f;
	m_fTargetThrust = 0.5f;
	m_vVelocity = m_aAircraftModel->m_fMaxThrust / 33220 * GetActorForwardVector();

	/*
		SOUND
	*/
	if (m_aAircraftModel->m_aEngineNoise!=nullptr)
		m_aAircraftModel->m_aEngineNoise->Activate();

	/*
		WEAPON POSITIONS
	*/
// 	m_aWeapon1->SetRelativeTransform(m_aAircraftModel->m_uHardPoint1);
// 	m_aWeapon2->SetRelativeTransform(m_aAircraftModel->m_uHardPoint2);
// 	m_aWeapon3->SetRelativeTransform(m_aAircraftModel->m_uHardPoint3);
// 	m_aWeapon4->SetRelativeTransform(m_aAircraftModel->m_uHardPoint4);
// 	m_aWeapon5->SetRelativeTransform(m_aAircraftModel->m_uHardPoint5);
// 	m_aWeapon6->SetRelativeTransform(m_aAircraftModel->m_uHardPoint6);
// 	m_aWeapon7->SetRelativeTransform(m_aAircraftModel->m_uHardPoint7);
// 	m_aWeapon8->SetRelativeTransform(m_aAircraftModel->m_uHardPoint8);
	
	EquipLoadout();

}

/**
	Updates the physics of the aircraft
*/
void AAircraftBase::PhysicsUpdate(float a_fDeltaTime)
{
	//Set afterburner and airbrake bools accordingly;
	m_bAfterburner = m_fCurrentThrust > 0.95f;
	m_bAirbrake = m_fTargetThrust < (m_fCurrentThrust - 0.01f) && m_fTargetThrust < 0.4f;
	
	/*
		Calculating Lift: 
		-----------------

		Lift = 0.5 * Air Density * True Airspeed Velocity^2 * Wing Area * Lift Coefficient
		

		Air density varies based on air temperature and altitude TODO: calculate this

		True airspeed needs to be calculated separately as there is variation in airspeed types.

		Wing area varies from aircraft to aircraft, obviously
		   
		The lift coefficient is a dimensionless coefficient that relates the lift generated by a lifting body to the
			fluid density around the body, the fluid velocity and an associated reference area. - Wikipedia

		I'll define the lift coefficient based upon the base (0 degree AoA) coefficient in proportion to the AoA.
		Traditionally, lift increases with angle against the airflow up until about the 15 degree point (citation needed) and then collapses.

		Lift Coefficient = Base LC * k
	*/
	FVector l_vLift = this->GetActorUpVector() * 0.5f * 1.29f * (m_fCurrentSpeed * m_fCurrentSpeed) *  m_aAircraftModel->m_fWingArea *  m_aAircraftModel->m_fLiftCESimplified;


	/*
		Calculating Gravity:
		-----------------

		This is very simple and relies upon the standard scientific definition of gravity to 3 decimal places


		Gravity = down vector * 9.806

		TODO: calculate this once in constructor and apply from thereon
	*/
	FVector l_vGravity = FVector::DownVector * 980.6f;


	/*
		Calculating Thrust:
		-----------------

		Rather than going through the entire physics of a jet engine, re; rotor and stator compressive efficiencies, rotation speed, 
		fuel burn rates	and expansion properties, various instances of the venturi effect, etc; I'm simply going to have a solidly
		defined thrust range, and thrust output will accelerate towards the target thrust as such:
		
		Thrust = Thrust + (Target Thrust - Thrust) * Thrust Acceleration * Delta Time

			where Target Thrust = Base Thrust + Thrust Range * Thrust Input


		This is then applied to the forward vector of the aircraft:
		l_vThrust = ((minimumThrottleMultiplier + ((1-minimumThrottleMultiplier) * m_fCurrentThrust)) * m_fMaxThrust) * ForwardVector

	*/
	//Update thrust scalar
	m_fCurrentThrust += (m_fTargetThrust - m_fCurrentThrust) *  m_aAircraftModel->m_fThrustAcceleration * a_fDeltaTime;

	//Set thrust to the relevant thrust * scalar
	if (m_bAfterburner)
	{
		m_vThrust = GetActorForwardVector() * ((0.5f + (0.5f * m_fCurrentThrust)) *  m_aAircraftModel->m_fABThrust);
	}

	else
	{
		m_vThrust = GetActorForwardVector() * ((0.5f + (0.5f * m_fCurrentThrust)) *  m_aAircraftModel->m_fMaxThrust);
	}
	//FVector l_vThrust = (m_fCurrentThrust * m_fMaxThrust) * this->GetActorForwardVector();
	

	/*
		Calculating Drag:
		-----------------

		Drag = 0.5 * Air Density * True Airspeed Velocity^2 * Drag Coefficient * Area


		Air density varies based on air temperature and altitude

		True airspeed needs to be calculated separately as there is variation in airspeed types.

		Area varies from aircraft to aircraft, obviously

		In fluid dynamics, the drag coefficient is a dimensionless quantity that is used to quantify the drag or resistance of
			an object in a fluid environment, such as air or water. It is used in the drag equation in which a lower drag coefficient
			indicates the object will have less aerodynamic or hydrodynamic drag. The drag coefficient is always associated with a
			particular surface area. - Wikipedia

		"the drag coefficient is a dimensionless quantity" - stuff that, let's make it dimensional.

		Because the amount of drag on the aircraft is going to differ based upon where the air is hitting it, we need a way of
		quantifying it. As alluded to in the header file; this will be found by finding the vectorial difference between the velocity
		of the aircraft and the direction the aircraft is pointing, and using it to weight against another 3 dimensional vector of
		drag coefficients to get the overall coefficient to apply in the airflow (opposite of velocity) direction. Drag Coefficient
		and Area are condensed down into one value.


		    vel %
		       / \ dif
			  /   \ 
			 ^     ^
	 plane  >|-  ---> 
			        dir

	*/

	FVector l_vDrag = m_vVelocity.GetSafeNormal() * (0.5f * 1.29f * (m_fCurrentSpeed*m_fCurrentSpeed) *  (m_aAircraftModel->m_fDragCESimplified + (m_bAirbrake * 0.05f)));
	//Old broken code that didn't work for some reason even though it's theoretically equivalent:
	//FVector l_vDrag = 0.5f * 1.29f * (m_vVelocity*m_vVelocity) * m_fDragCESimplified;
	

	/*
		Calculating Velocity
		--------------------

		Force = Mass * Acceleration
										therefore
		Acceleration = Force / Mass


		Acceleration is distance per second per second, or rate of change of velocity
		So, to get velocity change you add the acceleration multiplied by time.

		All four forces of flight are given as a force, so need to be divided by mass in order to equal the acceleration.
		
			Velocity = Velocity + (Acceleration * Delta Time)
		therefore
			Velocity += (Gravity + (Lift Force + Thrust Force + Drag Force)/Mass) * Delta Time
	*/
	m_vVelocity += (l_vGravity + ((l_vLift + m_vThrust - l_vDrag) / m_aAircraftModel->m_fPhysicsMass)) * a_fDeltaTime;
	//m_vVelocity += (((m_fCurrentThrust * m_fMaxThrust * this->GetActorForwardVector()) - l_vDrag) / m_fPhysicsMass) * a_fDeltaTime;
	//m_vVelocity += (l_vGravity + (l_vLift / m_fPhysicsMass)) * a_fDeltaTime;


	//Used for HUD
	m_fCurrentSpeed = m_vVelocity.Size();
	
	//Set GForce
	m_fGForce = (m_vVelocity.GetSafeNormal() - GetActorForwardVector()).Size();
	
	/*
		Move aircraft with velocity
	*/
	this->AddActorWorldOffset(m_vVelocity * a_fDeltaTime);
	
	/*
		Add pitch rotation
	*/
	m_vRotVelocity.X = m_aAircraftModel->m_fRollCE * m_fRollInput;

	/*
		Add roll rotation
	*/
	m_vRotVelocity.Y = m_aAircraftModel->m_fPitchCE * m_fPitchInput;

	/*
		Add yaw rotation
	*/
	m_vRotVelocity.Z = m_aAircraftModel->m_fYawCE * m_fYawInput;

	/*
		Rotate aircraft with rotational velocity
	*/
	this->AddActorLocalRotation(m_rRotator.MakeFromEuler(m_vRotVelocity)*a_fDeltaTime);

}

/*
	Weapons setup
*/
void AAircraftBase::EquipLoadout()
{
	if (m_pLoadout != nullptr)
	{
		//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Orange, TEXT("LOADOUT LOADING"));

		m_pLoadout->GenerateMap();

		while (!m_pLoadout->Ready())
		{
			//wait for the mapping to be ready
		}

		auto& l_pMappings = m_pLoadout->m_aWeaponMappings;

		for (int32 l_iMappingIndex = 0; l_iMappingIndex < l_pMappings.Num(); l_iMappingIndex++)
		{
			AWeaponMapping* l_pMapping = l_pMappings[l_iMappingIndex];

			for (int32 l_iHardpointIndex = 0; l_iHardpointIndex < l_pMapping->m_aHardpoints.Num(); l_iHardpointIndex++)
			{

				//m_aWeapon1->SetChildActorClass(l_pMapping->GetWeapon()->GetClass());

				//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Green, TEXT("Weapon emplacement"));

				UChildActorComponent* l_pWeapon = nullptr;
				UArrowComponent* l_pHardPoint = nullptr;


				switch (l_pMapping->m_aHardpoints[l_iHardpointIndex])
				{
					case 1:
						l_pWeapon = m_aWeapon1;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint1;
						break;
					case 2:
						l_pWeapon = m_aWeapon2;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint2;
						break;
					case 3:
						l_pWeapon = m_aWeapon3;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint3;
						break;
					case 4:
						l_pWeapon = m_aWeapon4;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint4;
						break;
					case 5:
						l_pWeapon = m_aWeapon5;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint5;
						break;
					case 6:
						l_pWeapon = m_aWeapon6;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint6;
						break;
					case 7:
						l_pWeapon = m_aWeapon7;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint7;
						break;
					case 8:
						l_pWeapon = m_aWeapon8;
						l_pHardPoint = m_aAircraftModel->m_uHardPoint8;
						break;

					default:
						//uh oh, someone's set the mapping up wrong
						GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, TEXT("uh oh, someone's set the mapping up wrong"));
						break;
				}

				/*if (l_pClass == nullptr)
				{
					//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, TEXT("WEAPON CLASS NULL"));
				}
				else
				{
					l_pWeapon->SetChildActorClass(l_pMapping->GetWeapon()->m_aWeaponComponent->GetChildActorClass());
					//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Orange, l_pClass->GetName());
				}*/


				l_pWeapon->SetChildActorClass(l_pMapping->GetWeapon()->m_aWeaponComponent->GetChildActorClass());

				//auto transformBuffer = l_pHardPoint->GetRelativeTransform();
				//auto rotationBuffer = l_pHardPoint->RelativeRotation;

				//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Green, l_pHardPoint.GetLocation().ToCompactString());
				l_pWeapon->SetWorldTransform(l_pHardPoint->GetComponentToWorld());
				//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, l_pWeapon->RelativeLocation.ToCompactString());

				//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Orange, locationBuffer.ToCompactString());
				//l_pWeapon->SetRelativeLocation(locationBuffer);
				//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, l_pWeapon->RelativeLocation.ToCompactString());

				//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Green, rotationBuffer.ToCompactString());
				//l_pWeapon->SetRelativeRotation(rotationBuffer);
				//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Emerald, l_pWeapon->RelativeRotation.ToCompactString());
// 
// 				l_pWeapon->SetHiddenInGame(false);
// 				l_pWeapon->bAbsoluteLocation = false;
// 				l_pWeapon->SetVisibility(true);
			}
		}

		//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Orange, TEXT("LOADOUT READY"));

	}
	else
	{
		//GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, TEXT("LOADOUT FAILED"));
	}

/*
if (!m_pLoadout->Ready())
{
	//loop until the loadout is ready,
	GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Red, TEXT("LOADOUT NOT READY"));
}
else
{
	GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Green, TEXT("LOADOUT READY"));
}
*/

}

// Called every frame
void AAircraftBase::Tick(float a_fDeltaTime)
{
	Super::Tick(a_fDeltaTime);

	//Update aircraft velocity, position, rotation
	AAircraftBase::PhysicsUpdate(a_fDeltaTime);

	//Animate left engine
	if (m_aLeftEngine != nullptr)
		m_aLeftEngine->SetThrust(m_fCurrentThrust);

	//Animate right engine
	if (m_aRightEngine != nullptr)
		m_aRightEngine->SetThrust(m_fCurrentThrust);

	//Animate contrails
	m_aAircraftModel->m_aLeftContrail->SetVectorParameter("ContrailPower", 
		FVector::OneVector*m_fGForce
	);
	m_aAircraftModel->m_aRightContrail->SetVectorParameter("ContrailPower",
		FVector::OneVector*m_fGForce
	);

	
	/*
		SOUND
	*/
	m_aAircraftModel->m_aEngineNoise->SetFloatParameter("ThrustPitch", m_fCurrentThrust);
	m_aAircraftModel->m_aEngineNoise->SetFloatParameter("ThrustVolume", m_fCurrentThrust + (m_bAirbrake * 0.5f));
	m_aAircraftModel->m_aEngineNoise->SetFloatParameter("AfterburnerPitch", m_fCurrentThrust);
	m_aAircraftModel->m_aEngineNoise->SetFloatParameter("AfterburnerVolume", m_fCurrentThrust);
	m_aAircraftModel->m_aEngineNoise->SetIntParameter("Afterburner", m_bAfterburner);
	
}

void AAircraftBase::SetPitch(float a_fAxisValue)
{
	m_fPitchInput = a_fAxisValue;
	m_aAircraftModel->SetElevatorAngle(a_fAxisValue);
}
void AAircraftBase::SetRoll(float a_fAxisValue)
{
	m_fRollInput = a_fAxisValue;
	m_aAircraftModel->SetAileronAngle(a_fAxisValue);
}
void AAircraftBase::SetYaw(float a_fAxisValue)
{
	m_fYawInput = a_fAxisValue;
	m_aAircraftModel->SetRudderAngle(a_fAxisValue);
}
void AAircraftBase::SetThrust(float a_fAxisValue)
{
	m_fTargetThrust = a_fAxisValue;
	m_aAircraftModel->SetAirbrakeAngle(m_bAirbrake);
}